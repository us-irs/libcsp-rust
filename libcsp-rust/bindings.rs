/* automatically generated by rust-bindgen 0.69.4 */

pub const CSP_ERR_NONE: u32 = 0;
pub const CSP_ERR_NOMEM: i32 = -1;
pub const CSP_ERR_INVAL: i32 = -2;
pub const CSP_ERR_TIMEDOUT: i32 = -3;
pub const CSP_ERR_USED: i32 = -4;
pub const CSP_ERR_NOTSUP: i32 = -5;
pub const CSP_ERR_BUSY: i32 = -6;
pub const CSP_ERR_ALREADY: i32 = -7;
pub const CSP_ERR_RESET: i32 = -8;
pub const CSP_ERR_NOBUFS: i32 = -9;
pub const CSP_ERR_TX: i32 = -10;
pub const CSP_ERR_DRIVER: i32 = -11;
pub const CSP_ERR_AGAIN: i32 = -12;
pub const CSP_ERR_NOSYS: i32 = -38;
pub const CSP_ERR_HMAC: i32 = -100;
pub const CSP_ERR_CRC32: i32 = -102;
pub const CSP_ERR_SFP: i32 = -103;
pub const CSP_POSIX: u32 = 1;
pub const CSP_ZEPHYR: u32 = 0;
pub const CSP_HAVE_STDIO: u32 = 1;
pub const CSP_ENABLE_CSP_PRINT: u32 = 1;
pub const CSP_PRINT_STDIO: u32 = 1;
pub const CSP_REPRODUCIBLE_BUILDS: u32 = 0;
pub const CSP_QFIFO_LEN: u32 = 15;
pub const CSP_PORT_MAX_BIND: u32 = 16;
pub const CSP_CONN_RXQUEUE_LEN: u32 = 16;
pub const CSP_CONN_MAX: u32 = 8;
pub const CSP_BUFFER_SIZE: u32 = 256;
pub const CSP_BUFFER_COUNT: u32 = 15;
pub const CSP_RDP_MAX_WINDOW: u32 = 5;
pub const CSP_RTABLE_SIZE: u32 = 10;
pub const CSP_USE_RDP: u32 = 1;
pub const CSP_USE_HMAC: u32 = 1;
pub const CSP_USE_PROMISC: u32 = 1;
pub const CSP_USE_RTABLE: u32 = 1;
pub const CSP_HAVE_LIBSOCKETCAN: u32 = 0;
pub const CSP_HAVE_LIBZMQ: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const CSP_DBG_ERR_CORRUPT_BUFFER: u32 = 1;
pub const CSP_DBG_ERR_MTU_EXCEEDED: u32 = 2;
pub const CSP_DBG_ERR_ALREADY_FREE: u32 = 3;
pub const CSP_DBG_ERR_REFCOUNT: u32 = 4;
pub const CSP_DBG_ERR_INVALID_RTABLE_ENTRY: u32 = 6;
pub const CSP_DBG_ERR_UNSUPPORTED: u32 = 7;
pub const CSP_DBG_ERR_INVALID_BIND_PORT: u32 = 8;
pub const CSP_DBG_ERR_PORT_ALREADY_IN_USE: u32 = 9;
pub const CSP_DBG_ERR_ALREADY_CLOSED: u32 = 10;
pub const CSP_DBG_ERR_INVALID_POINTER: u32 = 11;
pub const CSP_DBG_ERR_CLOCK_SET_FAIL: u32 = 12;
pub const CSP_DBG_CAN_ERR_FRAME_LOST: u32 = 1;
pub const CSP_DBG_CAN_ERR_RX_OVF: u32 = 2;
pub const CSP_DBG_CAN_ERR_RX_OUT: u32 = 3;
pub const CSP_DBG_CAN_ERR_SHORT_BEGIN: u32 = 4;
pub const CSP_DBG_CAN_ERR_INCOMPLETE: u32 = 5;
pub const CSP_DBG_CAN_ERR_UNKNOWN: u32 = 6;
pub const CSP_DBG_ETH_ERR_FRAME_LOST: u32 = 1;
pub const CSP_DBG_ETH_ERR_RX_OVF: u32 = 2;
pub const CSP_DBG_ETH_ERR_RX_OUT: u32 = 3;
pub const CSP_DBG_ETH_ERR_SHORT_BEGIN: u32 = 4;
pub const CSP_DBG_ETH_ERR_INCOMPLETE: u32 = 5;
pub const CSP_DBG_ETH_ERR_UNKNOWN: u32 = 6;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CSP_QUEUE_OK: u32 = 0;
pub const CSP_QUEUE_ERROR: i32 = -1;
pub const CSP_ANY: u32 = 255;
pub const CSP_FRES1: u32 = 128;
pub const CSP_FRES2: u32 = 64;
pub const CSP_FRES3: u32 = 32;
pub const CSP_FFRAG: u32 = 16;
pub const CSP_FHMAC: u32 = 8;
pub const CSP_FRDP: u32 = 2;
pub const CSP_FCRC32: u32 = 1;
pub const CSP_SO_NONE: u32 = 0;
pub const CSP_SO_RDPREQ: u32 = 1;
pub const CSP_SO_RDPPROHIB: u32 = 2;
pub const CSP_SO_HMACREQ: u32 = 4;
pub const CSP_SO_HMACPROHIB: u32 = 8;
pub const CSP_SO_CRC32REQ: u32 = 64;
pub const CSP_SO_CRC32PROHIB: u32 = 128;
pub const CSP_SO_CONN_LESS: u32 = 256;
pub const CSP_SO_SAME: u32 = 32768;
pub const CSP_O_NONE: u32 = 0;
pub const CSP_O_RDP: u32 = 1;
pub const CSP_O_NORDP: u32 = 2;
pub const CSP_O_HMAC: u32 = 4;
pub const CSP_O_NOHMAC: u32 = 8;
pub const CSP_O_CRC32: u32 = 64;
pub const CSP_O_NOCRC32: u32 = 128;
pub const CSP_O_SAME: u32 = 32768;
pub const CSP_PACKET_PADDING_BYTES: u32 = 8;
pub const CSP_RDP_HEADER_SIZE: u32 = 5;
pub const CSP_HOSTNAME_LEN: u32 = 20;
pub const CSP_MODEL_LEN: u32 = 30;
pub const CSP_REBOOT_MAGIC: u32 = 2147975175;
pub const CSP_REBOOT_SHUTDOWN_MAGIC: u32 = 3521467034;
pub const CSP_IFLIST_NAME_MAX: u32 = 10;
pub const CSP_NO_VIA_ADDRESS: u32 = 65535;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const CSP_MAX_TIMEOUT: u32 = 4294967295;
pub const CSP_MAX_DELAY: u32 = 4294967295;
pub const CSP_INFINITY: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    #[doc = " Error counters"]
    pub static mut csp_dbg_buffer_out: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_out: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_ovf: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_noroute: u8;
}
extern "C" {
    pub static mut csp_dbg_inval_reply: u8;
}
extern "C" {
    pub static mut csp_dbg_errno: u8;
}
extern "C" {
    pub static mut csp_dbg_can_errno: u8;
}
extern "C" {
    pub static mut csp_dbg_eth_errno: u8;
}
extern "C" {
    pub static mut csp_dbg_rdp_print: u8;
}
extern "C" {
    pub static mut csp_dbg_packet_print: u8;
}
extern "C" {
    pub fn csp_print_func(fmt: *const ::std::os::raw::c_char, ...);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type csp_queue_handle_t = *mut ::std::os::raw::c_void;
pub type csp_static_queue_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn csp_queue_create_static(
        length: ::std::os::raw::c_int,
        item_size: usize,
        buffer: *mut ::std::os::raw::c_char,
        queue: *mut csp_static_queue_t,
    ) -> csp_queue_handle_t;
}
extern "C" {
    #[doc = " Enqueue (back) value.\n\n @param[in] handle queue.\n @param[in] value value to add (by copy)\n @param[in] timeout timeout, time to wait for free space\n @return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_enqueue(
        handle: csp_queue_handle_t,
        value: *const ::std::os::raw::c_void,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enqueue (back) value from ISR.\n\n @param[in] handle queue.\n @param[in] value value to add (by copy)\n @param[out] pxTaskWoken Valid reference if called from ISR, otherwise NULL!\n @return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_enqueue_isr(
        handle: csp_queue_handle_t,
        value: *const ::std::os::raw::c_void,
        pxTaskWoken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dequeue value (front).\n\n @param[in] handle queue.\n @param[out] buf extracted element (by copy).\n @param[in] timeout timeout, time to wait for element in queue.\n @return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_dequeue(
        handle: csp_queue_handle_t,
        buf: *mut ::std::os::raw::c_void,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dequeue value (front) from ISR.\n\n @param[in] handle queue.\n @param[out] buf extracted element (by copy).\n @param[out] pxTaskWoken Valid reference if called from ISR, otherwise NULL!\n @return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_dequeue_isr(
        handle: csp_queue_handle_t,
        buf: *mut ::std::os::raw::c_void,
        pxTaskWoken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queue size.\n\n @param[in] handle handle queue.\n @return Number of elements in the queue."]
    pub fn csp_queue_size(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queue size from ISR.\n\n @param[in] handle handle queue.\n @return Number of elements in the queue."]
    pub fn csp_queue_size_isr(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free queue object (handle).\n\n @param[in] handle handle queue."]
    pub fn csp_queue_free(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_timestamp_t {
    pub tv_sec: u32,
    pub tv_nsec: u32,
}
#[test]
fn bindgen_test_layout_csp_timestamp_t() {
    const UNINIT: ::std::mem::MaybeUninit<csp_timestamp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_timestamp_t>(),
        8usize,
        concat!("Size of: ", stringify!(csp_timestamp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_timestamp_t>(),
        4usize,
        concat!("Alignment of ", stringify!(csp_timestamp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_timestamp_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_timestamp_t),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub const csp_service_port_t_CSP_CMP: csp_service_port_t = 0;
pub const csp_service_port_t_CSP_PING: csp_service_port_t = 1;
pub const csp_service_port_t_CSP_PS: csp_service_port_t = 2;
pub const csp_service_port_t_CSP_MEMFREE: csp_service_port_t = 3;
pub const csp_service_port_t_CSP_REBOOT: csp_service_port_t = 4;
pub const csp_service_port_t_CSP_BUF_FREE: csp_service_port_t = 5;
pub const csp_service_port_t_CSP_UPTIME: csp_service_port_t = 6;
#[doc = "  Reserved ports for CSP services."]
pub type csp_service_port_t = ::std::os::raw::c_uint;
#[doc = "!< Critical"]
pub const csp_prio_t_CSP_PRIO_CRITICAL: csp_prio_t = 0;
#[doc = "!< High"]
pub const csp_prio_t_CSP_PRIO_HIGH: csp_prio_t = 1;
#[doc = "!< Normal (default)"]
pub const csp_prio_t_CSP_PRIO_NORM: csp_prio_t = 2;
#[doc = "!< Low"]
pub const csp_prio_t_CSP_PRIO_LOW: csp_prio_t = 3;
#[doc = "Message priority."]
pub type csp_prio_t = ::std::os::raw::c_uint;
#[doc = "CSP identifier/header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __packed {
    pub pri: u8,
    pub flags: u8,
    pub src: u16,
    pub dst: u16,
    pub dport: u8,
    pub sport: u8,
}
#[test]
fn bindgen_test_layout___packed() {
    const UNINIT: ::std::mem::MaybeUninit<__packed> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__packed>(),
        8usize,
        concat!("Size of: ", stringify!(__packed))
    );
    assert_eq!(
        ::std::mem::align_of::<__packed>(),
        2usize,
        concat!("Alignment of ", stringify!(__packed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dport) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sport) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(__packed),
            "::",
            stringify!(sport)
        )
    );
}
#[doc = "CSP identifier/header."]
pub type csp_id_t = __packed;
#[doc = " CSP Packet.\n\n This structure is constructed to fit with all interface and protocols to prevent the\n need to copy data (zero copy).\n\n .. note:: In most cases a CSP packet cannot be reused in case of send failure, because the\n \t\t\t lower layers may add additional data causing increased length (e.g. CRC32), convert\n \t\t\t the CSP id to different endian (e.g. I2C), etc.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct csp_packet_s {
    pub __bindgen_anon_1: csp_packet_s__bindgen_ty_1,
    pub length: u16,
    pub id: csp_id_t,
    pub next: *mut csp_packet_s,
    #[doc = " Additional header bytes, to prepend packed data before transmission\n This must be minimum 6 bytes to accomodate CSP 2.0. But some implementations\n require much more scratch working area for encryption for example.\n\n Ultimately after csp_id_pack() this area will be filled with the CSP header"]
    pub header: [u8; 8usize],
    pub __bindgen_anon_2: csp_packet_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union csp_packet_s__bindgen_ty_1 {
    pub __bindgen_anon_1: csp_packet_s__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: csp_packet_s__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_packet_s__bindgen_ty_1__bindgen_ty_1 {
    pub rdp_quarantine: u32,
    pub timestamp_tx: u32,
    pub timestamp_rx: u32,
    pub conn: *mut csp_conn_s,
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp_quarantine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp_quarantine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_tx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(timestamp_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_rx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(timestamp_rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(conn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_packet_s__bindgen_ty_1__bindgen_ty_2 {
    pub rx_count: u16,
    pub remain: u16,
    pub cfpid: u32,
    pub last_used: u32,
    pub frame_begin: *mut u8,
    pub frame_length: u16,
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rx_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remain) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(remain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfpid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cfpid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_used) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(last_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_begin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(frame_begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(frame_length)
        )
    );
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(csp_packet_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_packet_s__bindgen_ty_1))
    );
}
#[doc = " Data part of packet:"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union csp_packet_s__bindgen_ty_2 {
    pub data: [u8; 256usize],
    pub data16: [u16; 128usize],
    pub data32: [u32; 64usize],
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_2>(),
        256usize,
        concat!("Size of: ", stringify!(csp_packet_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(csp_packet_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data32)
        )
    );
}
#[test]
fn bindgen_test_layout_csp_packet_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s>(),
        320usize,
        concat!("Size of: ", stringify!(csp_packet_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_packet_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(header)
        )
    );
}
#[doc = " CSP Packet.\n\n This structure is constructed to fit with all interface and protocols to prevent the\n need to copy data (zero copy).\n\n .. note:: In most cases a CSP packet cannot be reused in case of send failure, because the\n \t\t\t lower layers may add additional data causing increased length (e.g. CRC32), convert\n \t\t\t the CSP id to different endian (e.g. I2C), etc.\n"]
pub type csp_packet_t = csp_packet_s;
#[doc = " Forward declaration of CSP interface, see #csp_iface_s for details."]
pub type csp_iface_t = csp_iface_s;
pub type csp_callback_t = ::std::option::Option<unsafe extern "C" fn(packet: *mut csp_packet_t)>;
#[doc = " @brief Connection struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_socket_s {
    pub rx_queue: csp_queue_handle_t,
    pub rx_queue_static: csp_static_queue_t,
    pub rx_queue_static_data: [::std::os::raw::c_char; 128usize],
    pub opts: u32,
}
#[test]
fn bindgen_test_layout_csp_socket_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_socket_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_socket_s>(),
        152usize,
        concat!("Size of: ", stringify!(csp_socket_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_socket_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_socket_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue_static) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue_static)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue_static_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue_static_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(opts)
        )
    );
}
#[doc = " Forward declaration of socket structure"]
pub type csp_socket_t = csp_socket_s;
#[doc = " Forward declaration of connection structure"]
pub type csp_conn_t = csp_conn_s;
#[doc = " Memory pointer"]
pub type csp_memptr_t = *mut ::std::os::raw::c_void;
#[doc = " Const memory pointer"]
pub type csp_const_memptr_t = *const ::std::os::raw::c_void;
#[doc = " Platform specific memory copy function."]
pub type csp_memcpy_fnc_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: csp_memptr_t, arg2: csp_const_memptr_t, arg3: usize) -> csp_memptr_t,
>;
extern "C" {
    #[doc = " Get free buffer from task context.\n\n @param[in] unused OBSOLETE ignored field, csp packets have a fixed size now\n @return Buffer pointer to #csp_packet_t or NULL if no buffers available"]
    pub fn csp_buffer_get(unused: usize) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = " Get free buffer (from ISR context).\n\n @param[in] unused OBSOLETE ignored field, csp packets have a fixed size now\n @return Buffer pointer to #csp_packet_t or NULL if no buffers available"]
    pub fn csp_buffer_get_isr(unused: usize) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = " Free buffer (from task context).\n\n @param[in] buffer buffer to free. NULL is handled gracefully."]
    pub fn csp_buffer_free(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Free buffer (from ISR context).\n\n @param[in] buffer buffer to free. NULL is handled gracefully."]
    pub fn csp_buffer_free_isr(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Clone an existing buffer.\n The existing \\a buffer content is copied to the new buffer.\n\n @param[in] buffer buffer to clone.\n @return cloned buffer on success, or NULL on failure."]
    pub fn csp_buffer_clone(buffer: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Return number of remaining/free buffers.\n The number of buffers is set by csp_init().\n\n @return number of remaining/free buffers"]
    pub fn csp_buffer_remaining() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_buffer_init();
}
extern "C" {
    #[doc = " Increase reference counter of buffer.\n Use csp_buffer_free() to decrement\n @param[in] buffer buffer to increment. NULL is handled gracefully."]
    pub fn csp_buffer_refc_inc(buffer: *mut ::std::os::raw::c_void);
}
#[doc = " Interface Tx function.\n\n @return #CSP_ERR_NONE on success, otherwise an error code."]
pub type nexthop_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: *mut csp_iface_t,
        via: u16,
        packet: *mut csp_packet_t,
        from_me: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " This struct is referenced in documentation.\n Update doc when you change this."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_iface_s {
    #[doc = "< Host address on this subnet"]
    pub addr: u16,
    #[doc = "< Subnet mask"]
    pub netmask: u16,
    #[doc = "< Name, max compare length is #CSP_IFLIST_NAME_MAX"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Interface data, only known/used by the interface layer, e.g. state information."]
    pub interface_data: *mut ::std::os::raw::c_void,
    #[doc = "< Driver data, only known/used by the driver layer, e.g. device/channel references."]
    pub driver_data: *mut ::std::os::raw::c_void,
    #[doc = "< Next hop (Tx) function"]
    pub nexthop: nexthop_t,
    #[doc = "< Set default IF flag (CSP supports multiple defaults)"]
    pub is_default: u8,
    #[doc = "< Successfully transmitted packets"]
    pub tx: u32,
    #[doc = "< Successfully received packets"]
    pub rx: u32,
    #[doc = "< Transmit errors (packets)"]
    pub tx_error: u32,
    #[doc = "< Receive errors, e.g. too large message"]
    pub rx_error: u32,
    #[doc = "< Dropped packets"]
    pub drop: u32,
    #[doc = "< Authentication errors (packets)"]
    pub autherr: u32,
    #[doc = "< Frame format errors (packets)"]
    pub frame: u32,
    #[doc = "< Transmitted bytes"]
    pub txbytes: u32,
    #[doc = "< Received bytes"]
    pub rxbytes: u32,
    #[doc = "< Interrupts"]
    pub irq: u32,
    pub next: *mut csp_iface_s,
}
#[test]
fn bindgen_test_layout_csp_iface_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_iface_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_iface_s>(),
        96usize,
        concat!("Size of: ", stringify!(csp_iface_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_iface_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_iface_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(interface_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nexthop) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(nexthop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_default) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(is_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_error) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(tx_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rx_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autherr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(autherr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txbytes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(txbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbytes) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rxbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irq) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Inputs a new packet into the system.\n\n This function can be called from interface drivers (ISR) or tasks, to route and accept packets.\n\n .. note:: EXTREMELY IMPORTANT: \\a pxTaskWoken must ALWAYS be NULL if called from task, and ALWAYS\n\t\t\t be NON NULL if called from ISR. If this condition is met, this call is completely thread-safe\n\n This function is fire and forget, it returns void, meaning that the \\a packet will always be\n either accepted or dropped, so the memory will always be freed.\n\n @param[in] packet A pointer to the incoming packet\n @param[in] iface A pointer to the incoming interface TX function.\n @param[in] pxTaskWoken Valid reference if called from ISR, otherwise NULL!\n"]
    pub fn csp_qfifo_write(
        packet: *mut csp_packet_t,
        iface: *mut csp_iface_t,
        pxTaskWoken: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Add interface to the list.\n\n @param[in] iface The interface must remain valid as long as the application is running.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_iflist_add(iface: *mut csp_iface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove interface from the list.\n\n @param[in] ifc Interface to remove. NULL will be gracefully handled."]
    pub fn csp_iflist_remove(ifc: *mut csp_iface_t);
}
extern "C" {
    pub fn csp_iflist_get_by_name(name: *const ::std::os::raw::c_char) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_addr(addr: u16) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_subnet(addr: u16, from: *mut csp_iface_t) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_isdfl(ifc: *mut csp_iface_t) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_index(idx: ::std::os::raw::c_int) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_is_within_subnet(addr: u16, ifc: *mut csp_iface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_iflist_get() -> *mut csp_iface_t;
}
extern "C" {
    #[doc = " Convert bytes to readable string"]
    pub fn csp_bytesize(
        bytes: ::std::os::raw::c_ulong,
        postfix: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Runs over the list of interfaces, and if no default interface is found\n set default on ALL interfaces"]
    pub fn csp_iflist_check_dfl();
}
extern "C" {
    pub fn csp_iflist_print();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_route_s {
    pub address: u16,
    pub netmask: u16,
    pub via: u16,
    pub iface: *mut csp_iface_t,
}
#[test]
fn bindgen_test_layout_csp_route_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_route_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_route_s>(),
        16usize,
        concat!("Size of: ", stringify!(csp_route_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_route_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_route_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).via) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(via)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(iface)
        )
    );
}
pub type csp_route_t = csp_route_s;
extern "C" {
    #[doc = " Loop through routes backwards and find routes that match on addr and mask from start_route"]
    pub fn csp_rtable_search_backward(start_route: *mut csp_route_t) -> *mut csp_route_t;
}
extern "C" {
    pub fn csp_rtable_find_route(dest_address: u16) -> *mut csp_route_t;
}
extern "C" {
    #[doc = " Set route to destination address/node.\n\n @param[in] dest_address destination address.\n @param[in]mask number of bits in netmask (set to -1 for maximum number of bits)\n @param[in] ifc interface.\n @param[in] via assosicated via address.\n @return #CSP_ERR_NONE on success, or an error code."]
    pub fn csp_rtable_set(
        dest_address: u16,
        netmask: ::std::os::raw::c_int,
        ifc: *mut csp_iface_t,
        via: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Save routing table as a string (readable format).\n @see csp_rtable_load() for additional information, e.g. format.\n\n @param[out] buffer user supplied buffer.\n @param[in] buffer_size size of \\a buffer.\n @return #CSP_ERR_NONE on success, or an error code."]
    pub fn csp_rtable_save(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Load routing table from a string.\n Table will be loaded on-top of existing routes, possibly overwriting existing entries.\n Format: \\<address\\>[/mask] \\<interface\\> [via][, next entry]\n Example: \"0/0 CAN, 8 KISS, 10 I2C 10\", same as \"0/0 CAN, 8/5 KISS, 10/5 I2C 10\".\n @see csp_rtable_save(), csp_rtable_clear(), csp_rtable_free()\n\n @param[in] rtable routing table (nul terminated)\n @return CSP_ERR or number of entries."]
    pub fn csp_rtable_load(rtable: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check string for valid routing elements.\n\n @param[in] rtable routing table (nul terminated)\n @return CSP_ERR or number of entries."]
    pub fn csp_rtable_check(rtable: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear routing table and add loopback route.\n @see csp_rtable_free()"]
    pub fn csp_rtable_clear();
}
extern "C" {
    #[doc = " Clear/free all entries in the routing table."]
    pub fn csp_rtable_free();
}
#[doc = " Iterator for looping through the routing table."]
pub type csp_rtable_iterator_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, route: *mut csp_route_t) -> bool,
>;
extern "C" {
    #[doc = " Iterate routing table."]
    pub fn csp_rtable_iterate(iter: csp_rtable_iterator_t, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Print routing table"]
    pub fn csp_rtable_print();
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Send data over a CSP connection.\n\n Data will be send in chunks of \\a mtu bytes. The MTU must be small enough to fit\n into a CSP packat + SFP header + other transport headers.\n\n csp_sfp_recv() or csp_sfp_recv_fp() can be used at the other end to receive data.\n\n This is usefull if you wish to send data stored in flash memory or another location, where standard memcpy() doesn't work.\n\n @param[in] conn established connection for sending SFP packets.\n @param[in] data data to send\n @param[in] datasize  tsize of \\a data\n @param[in] mtu  maximum transfer unit (bytes), max data chunk to send.\n @param[in] timeout unused as of CSP version 1.6\n @param[in] memcpyfcn memory copy function.\n @return #CSP_ERR_NONE on success, otherwise an error."]
    pub fn csp_sfp_send_own_memcpy(
        conn: *mut csp_conn_t,
        data: *const ::std::os::raw::c_void,
        datasize: ::std::os::raw::c_uint,
        mtu: ::std::os::raw::c_uint,
        timeout: u32,
        memcpyfcn: csp_memcpy_fnc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Receive data over a CSP connection.\n\n This is the counterpart to the csp_sfp_send() and csp_sfp_send_own_memcpy().\n\n @param[in] conn established connection for receiving SFP packets.\n @param[out] dataout received data on success. Allocated with malloc(), so\n \t\t\t   should be freed with free(). The pointer will be NULL on failure.\n @param[out] datasize size of received data.\n @param[in] timeout timeout in ms to wait for csp_read()\n @param[in] first_packet First packet of a SFP transfer.\n \t\t\t  Use NULL to receive first packet on the connection.\n @return #CSP_ERR_NONE on success, otherwise an error."]
    pub fn csp_sfp_recv_fp(
        conn: *mut csp_conn_t,
        dataout: *mut *mut ::std::os::raw::c_void,
        datasize: *mut ::std::os::raw::c_int,
        timeout: u32,
        first_packet: *mut csp_packet_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable promiscuous packet queue.\n\n @param[in]queue_size: Size (max length) of queue for incoming packets.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_promisc_enable(queue_size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable promiscuous mode."]
    pub fn csp_promisc_disable();
}
extern "C" {
    #[doc = " Get/dequeue packet from promiscuous packet queue.\n\n Returns the first packet from the promiscuous packet queue.\n\n @param[in] timeout Timeout in ms to wait for a packet.\n @return Packet (free with csp_buffer_free() or re-use packet), NULL on error or timeout."]
    pub fn csp_promisc_read(timeout: u32) -> *mut csp_packet_t;
}
#[doc = "< Deduplication off"]
pub const csp_dedup_types_CSP_DEDUP_OFF: csp_dedup_types = 0;
#[doc = "< Deduplication on forwarding only"]
pub const csp_dedup_types_CSP_DEDUP_FWD: csp_dedup_types = 1;
#[doc = "< Deduplication on incomfing only"]
pub const csp_dedup_types_CSP_DEDUP_INCOMING: csp_dedup_types = 2;
#[doc = "< Deduplication on incoming and forwarding"]
pub const csp_dedup_types_CSP_DEDUP_ALL: csp_dedup_types = 3;
#[doc = " CSP Debug Types"]
pub type csp_dedup_types = ::std::os::raw::c_uint;
#[doc = " CSP configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_conf_s {
    #[doc = "< Protocol version to use (either 1 or 2)"]
    pub version: u8,
    #[doc = "< Host name, returned by the #CSP_CMP_IDENT request"]
    pub hostname: *const ::std::os::raw::c_char,
    #[doc = "< Model, returned by the #CSP_CMP_IDENT request"]
    pub model: *const ::std::os::raw::c_char,
    #[doc = "< Revision, returned by the #CSP_CMP_IDENT request"]
    pub revision: *const ::std::os::raw::c_char,
    #[doc = "< Default connection options. Options will always be or'ed onto new connections, see csp_connect()"]
    pub conn_dfl_so: u32,
    #[doc = "< Enable CSP deduplication. 0 = off, 1 = always on, 2 = only on forwarded packets,"]
    pub dedup: u8,
}
#[test]
fn bindgen_test_layout_csp_conf_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_conf_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_conf_s>(),
        40usize,
        concat!("Size of: ", stringify!(csp_conf_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_conf_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_conf_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_dfl_so) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(conn_dfl_so)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedup) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(dedup)
        )
    );
}
#[doc = " CSP configuration."]
pub type csp_conf_t = csp_conf_s;
extern "C" {
    pub static mut csp_conf: csp_conf_t;
}
extern "C" {
    #[doc = " Initialize CSP.\n This will configure basic structures."]
    pub fn csp_init();
}
extern "C" {
    #[doc = " Free allocated resorces in CSP.\n This is intended for testing of CSP, in order to be able re-initialize CSP by calling csp_init() again."]
    pub fn csp_free_resources();
}
extern "C" {
    #[doc = " Get a \\a read-only reference to the active CSP configuration.\n\n @return Active CSP configuration (read-only)."]
    pub fn csp_get_conf() -> *const csp_conf_t;
}
extern "C" {
    #[doc = " Copy csp id fields from source to target object"]
    pub fn csp_id_copy(target: *mut csp_id_t, source: *mut csp_id_t);
}
extern "C" {
    #[doc = " Wait/accept a new connection.\n\n @param[in] socket socket to accept connections on, created by calling csp_socket().\n @param[in] timeout  timeout in mS to wait for a connection, use CSP_MAX_TIMEOUT for infinite timeout.\n @return New connection on success, NULL on failure or timeout."]
    pub fn csp_accept(socket: *mut csp_socket_t, timeout: u32) -> *mut csp_conn_t;
}
extern "C" {
    #[doc = " Read packet from a connection.\n This fuction will wait on the connection's RX queue for the specified timeout.\n\n @param[in] conn  connection\n @param[in] timeout timeout in mS to wait for a packet, use CSP_MAX_TIMEOUT for infinite timeout.\n @return Packet or NULL in case of failure or timeout."]
    pub fn csp_read(conn: *mut csp_conn_t, timeout: u32) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = " Send packet on a connection.\n The packet buffer is automatically freed, and cannot be used after the call to csp_send()\n\n @param[in] conn connection\n @param[in] packet packet to send"]
    pub fn csp_send(conn: *mut csp_conn_t, packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = " Change the default priority of the connection and send a packet.\n\n .. note:: The priority of the connection will be changed.\n           If you need to change it back, call csp_send_prio() again.\n\n @param[in] prio priority to set on the connection\n @param[in] conn connection\n @param[in] packet packet to send"]
    pub fn csp_send_prio(prio: u8, conn: *mut csp_conn_t, packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = " Perform an entire request & reply transaction.\n Creates a connection, send \\a outbuf, wait for reply, copy reply to \\a inbuf and close the connection.\n\n @param[in] prio priority, see #csp_prio_t\n @param[in] dst destination address\n @param[in] dst_port destination port\n @param[in] timeout timeout in mS to wait for a reply\n @param[in] outbuf outgoing data (request)\n @param[in] outlen length of data in \\a outbuf (request)\n @param[out] inbuf user provided buffer for receiving data (reply)\n @param[in] inlen length of expected reply, -1 for unknown size (inbuf MUST be large enough), 0 for no reply.\n @param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n\n Returns:\n   int: 1 or reply size on success, 0 on failure (error, incoming length does not match, timeout)"]
    pub fn csp_transaction_w_opts(
        prio: u8,
        dst: u16,
        dst_port: u8,
        timeout: u32,
        outbuf: *mut ::std::os::raw::c_void,
        outlen: ::std::os::raw::c_int,
        inbuf: *mut ::std::os::raw::c_void,
        inlen: ::std::os::raw::c_int,
        opts: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform an entire request & reply transaction on an existing connection.\n Send \\a outbuf, wait for reply and copy reply to \\a inbuf.\n\n @param[in] conn connection\n @param[in] timeout timeout in mS to wait for a reply\n @param[in] outbuf outgoing data (request)\n @param[in] outlen length of data in \\a outbuf (request)\n @param[out] inbuf user provided buffer for receiving data (reply)\n @param[in] inlen length of expected reply, -1 for unknown size (inbuf MUST be large enough), 0 for no reply.\n @return 1 or reply size on success, 0 on failure (error, incoming length does not match, timeout)"]
    pub fn csp_transaction_persistent(
        conn: *mut csp_conn_t,
        timeout: u32,
        outbuf: *mut ::std::os::raw::c_void,
        outlen: ::std::os::raw::c_int,
        inbuf: *mut ::std::os::raw::c_void,
        inlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read data from a connection-less server socket.\n\n @param[in] socket connection-less socket.\n @param[in] timeout timeout in mS to wait for a packet, use #CSP_MAX_TIMEOUT for infinite timeout.\n @return Packet on success, or NULL on failure or timeout."]
    pub fn csp_recvfrom(socket: *mut csp_socket_t, timeout: u32) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = " Send a packet (without connection).\n\n @param[in] prio packet priority, see #csp_prio_t\n @param[in] dst destination address\n @param[in] dst_port destination port\n @param[in] src_port source port\n @param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n @param[in] packet packet to send"]
    pub fn csp_sendto(
        prio: u8,
        dst: u16,
        dst_port: u8,
        src_port: u8,
        opts: u32,
        packet: *mut csp_packet_t,
    );
}
extern "C" {
    #[doc = " Send a packet as a reply to a request (without a connection).\n Calls csp_sendto() with the source address and port from the request.\n\n @param[in] request incoming request\n @param[out] reply reply packet\n @param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS."]
    pub fn csp_sendto_reply(request: *const csp_packet_t, reply: *mut csp_packet_t, opts: u32);
}
extern "C" {
    #[doc = " Establish outgoing connection.\n The call will return immediately, unless it is a RDP connection (#CSP_O_RDP) in which case it will wait until the other\n end acknowleges the connection (timeout is determined by the current connection timeout set by csp_rdp_set_opt()).\n\n @param[in] prio priority, see #csp_prio_t\n @param[in] dst Destination address\n @param[in] dst_port Destination port\n @param[in] timeout unused.\n @param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n @return Established connection or NULL on failure (no free connections, timeout)."]
    pub fn csp_connect(
        prio: u8,
        dst: u16,
        dst_port: u8,
        timeout: u32,
        opts: u32,
    ) -> *mut csp_conn_t;
}
extern "C" {
    #[doc = " Close an open connection.\n Any packets in the RX queue will be freed.\n\n @param[in] conn connection. Closing a NULL connection is acceptable.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_close(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a socket, freeing it's RX queue and unbinding it from the associated\n port.\n\n @param[in] sock Socket\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_socket_close(sock: *mut csp_socket_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return destination port of connection.\n\n @param[in] conn connection\n @return destination port of an incoming connection"]
    pub fn csp_conn_dport(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return source port of connection.\n\n @param[in] conn connection\n @return source port of an incoming connection"]
    pub fn csp_conn_sport(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return destination address of connection.\n\n @param[in] conn connection\n @return destination address of an incoming connection"]
    pub fn csp_conn_dst(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return source address of connection.\n\n @param[in] conn connection\n @return source address of an incoming connection"]
    pub fn csp_conn_src(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return flags of connection.\n\n @param[in] conn connection\n @return flags of an incoming connection, see @ref CSP_HEADER_FLAGS"]
    pub fn csp_conn_flags(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set socket to listen for incoming connections.\n\n @param[in] socket socket\n @param[in] backlog max length of backlog queue. The backlog queue holds incoming connections, waiting to be returned by call to csp_accept().\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_listen(socket: *mut csp_socket_t, backlog: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bind port to socket.\n\n @param[in] socket socket to bind port to\n @param[in] port port number to bind, use #CSP_ANY for all ports. Bindnig to a specific will take precedence over #CSP_ANY.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_bind(socket: *mut csp_socket_t, port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bind port to callback function.\n\n @param[in] callback pointer to callback function\n @param[in] port port number to bind, use #CSP_ANY for all ports. Bindnig to a specific will take precedence over #CSP_ANY.\n @return 0 on success, otherwise an error code."]
    pub fn csp_bind_callback(callback: csp_callback_t, port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Route packet from the incoming router queue and check RDP timeouts.\n In order for incoming packets to routed and RDP timeouts to be checked, this function must be called reguarly.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_route_work() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the bridge interfaces.\n\n @param[in] if_a CSP Interface `A`\n @param[in] if_b CSP Interface `B`"]
    pub fn csp_bridge_set_interfaces(if_a: *mut csp_iface_t, if_b: *mut csp_iface_t);
}
extern "C" {
    #[doc = " Bridge packet from an interface to the other."]
    pub fn csp_bridge_work();
}
extern "C" {
    #[doc = " Handle CSP service request.\n If the given packet is a service-request (the destination port matches one of CSP service ports #csp_service_port_t),\n the packet will be processed by the specific CSP service handler.\n The packet will either process it or free it, so this function is typically called in the last \"default\" clause of\n a switch/case statement in a CSP listener task.\n In order to listen to csp service ports, bind your listener to the specific services ports #csp_service_port_t or\n use #CSP_ANY to all ports.\n\n @param[in] packet first packet, obtained by using csp_read()"]
    pub fn csp_service_handler(packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = " Send a single ping/echo packet.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in ms to wait for reply.\n @param[in] size payload size in bytes.\n @param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n @return >=0 echo time in mS on success, otherwise -1 for error."]
    pub fn csp_ping(
        node: u16,
        timeout: u32,
        size: ::std::os::raw::c_uint,
        opts: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a single ping/echo packet without waiting for reply.\n Payload is 1 byte.\n\n @param[in] node address of subsystem."]
    pub fn csp_ping_noreply(node: u16);
}
extern "C" {
    #[doc = " Request process list.\n\n .. note:: This is currently only supported on FreeRTOS systems.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for replies. The function will not return until the timeout occurrs."]
    pub fn csp_ps(node: u16, timeout: u32);
}
extern "C" {
    #[doc = " Request free memory.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply.\n @param[out] size free memory on subsystem.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_memfree(node: u16, timeout: u32, size: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request free memory and print to stdout.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply."]
    pub fn csp_memfree(node: u16, timeout: u32);
}
extern "C" {
    #[doc = " Request free buffers.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply.\n @param[out] size free buffers.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_buf_free(node: u16, timeout: u32, size: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Request free buffers and print to stdout.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply."]
    pub fn csp_buf_free(node: u16, timeout: u32);
}
extern "C" {
    #[doc = " Reboot subsystem.\n If handled by the standard CSP service handler, the reboot handler set by csp_sys_set_reboot() on the subsystem, will be invoked.\n\n @param[in] node address of subsystem.\n"]
    pub fn csp_reboot(node: u16);
}
extern "C" {
    #[doc = " Shutdown subsystem.\n If handled by the standard CSP service handler, the shutdown handler set by csp_sys_set_shutdown() on the subsystem, will be invoked.\n\n @param[in] node address of subsystem.\n"]
    pub fn csp_shutdown(node: u16);
}
extern "C" {
    #[doc = " Request uptime and print to stdout.\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply.\n"]
    pub fn csp_uptime(node: u16, timeout: u32);
}
extern "C" {
    #[doc = " Request uptime\n\n @param[in] node address of subsystem.\n @param[in] timeout timeout in mS to wait for reply.\n @param[out] uptime uptime in seconds.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_uptime(node: u16, timeout: u32, uptime: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set RDP options.\n The RDP options are used from the connecting/client side. When a RDP connection\n is established, the client tranmits the options to the server.\n\n @param[in] window_size window size\n @param[in] conn_timeout_ms connection timeout in mS\n @param[in] packet_timeout_ms packet timeout in mS.\n @param[in] delayed_acks enable/disable delayed acknowledgements.\n @param[in] ack_timeout acknowledgement timeout when delayed ACKs is enabled\n @param[in] ack_delay_count send acknowledgement for every ack_delay_count packets.\n"]
    pub fn csp_rdp_set_opt(
        window_size: ::std::os::raw::c_uint,
        conn_timeout_ms: ::std::os::raw::c_uint,
        packet_timeout_ms: ::std::os::raw::c_uint,
        delayed_acks: ::std::os::raw::c_uint,
        ack_timeout: ::std::os::raw::c_uint,
        ack_delay_count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Get RDP options. @see csp_rdp_set_opt()\n\n @param[out] window_size Window size\n @param[out] conn_timeout_ms connection timeout in ms\n @param[out] packet_timeout_ms packet timeout in ms\n @param[out] delayed_acks enable/disable delayed acknowledgements\n @param[out] ack_timeout acknowledgement timeout when delayed ACKs is enabled\n @param[out] ack_delay_count send acknowledgement for every ack_delay_count packets"]
    pub fn csp_rdp_get_opt(
        window_size: *mut ::std::os::raw::c_uint,
        conn_timeout_ms: *mut ::std::os::raw::c_uint,
        packet_timeout_ms: *mut ::std::os::raw::c_uint,
        delayed_acks: *mut ::std::os::raw::c_uint,
        ack_timeout: *mut ::std::os::raw::c_uint,
        ack_delay_count: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Set platform specific memory copy function."]
    pub fn csp_cmp_set_memcpy(fnc: csp_memcpy_fnc_t);
}
extern "C" {
    #[doc = " Print connection table to stdout."]
    pub fn csp_conn_print_table();
}
extern "C" {
    #[doc = " Hex dump memory to stdout.\n\n @param[in] desc description printed on first line.\n @param[in] addr memory address.\n @param[in] len number of bytes to dump, starting from \\a addr.\n"]
    pub fn csp_hex_dump(
        desc: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Print connection table to string."]
    pub fn csp_conn_print_table_str(
        str_buf: *mut ::std::os::raw::c_char,
        str_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_conn_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
